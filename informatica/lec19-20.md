### **Конспект лекции по информатике: "Основы компьютерной графики"**

**Пара 19-20**

**Цель:** Дать систематизированное представление о принципах, типах и областях применения компьютерной графики.

---

### **1. Введение: Что такое компьютерная графика?**

**Компьютерная графика (Computer Graphics)** — это область информатики, занимающаяся созданием, обработкой и отображением визуального контента (изображений, анимации, видео) с помощью компьютера.

**Основные области применения:**
*   **Визуализация:** Научная (молекулы, потоки жидкости), деловая (графики, диаграммы).
*   **Дизайн:** Графический, промышленный, веб-дизайн.
*   **Развлечения:** Компьютерные игры, спецэффекты в кино, анимация.
*   **Интерфейсы:** Пользовательские интерфейсы (UI) операционных систем и приложений.
*   **Виртуальная и дополненная реальность (VR/AR).**
*   **Компьютерное зрение и распознавание образов.**

---

### **2. Два фундаментальных типа графики**

#### **2.1. Растровая графика (Raster Graphics)**

**Определение:** Изображение, представляющее собой сетку (растр) пикселей — цветных точек, упорядоченных по строкам и столбцам.

**Ключевые понятия:**
*   **Пиксель (Picture Element):** Минимальный и неделимый элемент растрового изображения. Каждый пиксель имеет свой цвет.
*   **Разрешение (Resolution):** Количество пикселей по ширине и высоте изображения (например, 1920×1080). Чем выше разрешение, тем больше детализация.
*   **Глубина цвета (Color Depth):** Количество бит, используемых для кодирования цвета одного пикселя.
    *   **8-бит (256 цветов):** Индексированный цвет (GIF).
    *   **24-бит (True Color):** ~16.7 млн. цветов. По 8 бит на канал (R, G, B).
    *   **32-бит:** 24 бита на цвет + 8 бит на альфа-канал (прозрачность).
*   **Размер файла:** Рассчитывается как `(Ширина в пикселях × Высота в пикселях × Глубина цвета в битах) / 8` (в байтах). Наличие сжатия уменьшает размер.

**Плюсы:**
*   Реалистичное изображение, идеально для фотографий.
*   Широкий спектр цветов и плавные цветовые переходы.
*   Поддержка сложными эффектами (тени, размытие).

**Минусы:**
*   Потеря качества при масштабировании (пикселизация).
*   Большой размер файлов (особенно при отсутствии сжатия).

**Основные форматы:**
*   **JPEG (Joint Photographic Experts Group):** Сжатие с потерями. Идеален для фотографий. Не поддерживает прозрачность.
*   **PNG (Portable Network Graphics):** Сжатие без потерь. Поддерживает прозрачность (альфа-канал). Идеален для графики с четкими границами (логотипы, иконки).
*   **GIF (Graphics Interchange Format):** Поддерживает анимацию и простую прозрачность (1 бит, без полутонов). Ограниченная палитра (256 цветов).
*   **WebP:** Современный формат от Google. Обеспечивает лучшее сжатие, чем JPEG и PNG, поддерживает и анимацию, и прозрачность.
*   **BMP (Bitmap):** Несжатый формат. Очень большие размеры файлов.
*   **TIFF (Tagged Image File Format):** Используется в полиграфии, поддерживает слои и различные схемы сжатия.

---

#### **2.2. Векторная графика (Vector Graphics)**

**Определение:** Изображение, описываемое с помощью математических формул (геометрических примитивов): точек, линий, кривых, многоугольников.

**Ключевые понятия:**
*   **Контур (Path):** Линия, описываемая точками (нодами). Кривизна контролируется векторами (ручками Безье).
*   **Обводка (Stroke) и Заливка (Fill):** Стили, применяемые к контуру.
*   **Масштабируемость:** Поскольку изображение описывается формулами, его можно масштабировать до бесконечности без потери качества.

**Плюсы:**
*   Не зависит от разрешения. Масштабируется без потерь.
*   Маленький размер файла (для простых изображений).
*   Легкость редактирования отдельных элементов.
*   Идеально для логотипов, иконок, шрифтов, чертежей.

**Минусы:**
*   Не подходит для создания фотореалистичных изображений.
*   Сложность описания сложных сцен (например, волос или листвы).

**Основные форматы:**
*   **SVG (Scalable Vector Graphics):** Открытый стандарт на основе XML. Может быть интерактивным и анимированным с помощью CSS/JavaScript. **Король веба** для векторной графики.
*   **AI (Adobe Illustrator):** Проприетарный формат Adobe Illustrator.
*   **EPS (Encapsulated PostScript):** Универсальный формат для полиграфии.
*   **PDF (Portable Document Format):** Может содержать как векторные, так и растровые данные.

---

### **3. Цветовые модели (Color Models)**

Это математические модели для описания цвета в виде набора чисел.

*   **RGB (Red, Green, Blue):** **Аддитивная модель.** Используется в мониторах, телевизорах, сканерах. Цвет получается путем сложения (add) излучений основных цветов. `(0,0,0)` — черный, `(255,255,255)` — белый. Представление: `rgb(255, 0, 0)`, `#FF0000`.
*   **CMYK (Cyan, Magenta, Yellow, Key/Black):** **Субтрактивная модель.** Используется в цветной печати. Цвет получается путем вычитания (subtract) света, поглощаемого краской на бумаге. `(0,0,0,0)` — белый (цвет бумаги).
*   **HSB/HSL (Hue, Saturation, Brightness/Lightness):** Модель, интуитивно понятная для человека.
    *   **Hue (Оттенок):** Сам цвет (0°-360°).
    *   **Saturation (Насыщенность):** Интенсивность цвета (0% - серый, 100% - чистый цвет).
    *   **Brightness/Lightness (Яркость/Светлота):** Уровень света в цвете.

---

### **4. Основы 3D-графики**

3D-графика не является отдельным типом, как растровая или векторная. Это процесс создания и отображения трехмерных сцен, который заканчивается **растеризацией** — преобразованием в 2D-растровое изображение для вывода на экран.

**Основные этапы конвейера рендеринга (Rendering Pipeline):**

1.  **Моделирование (Modeling):** Создание 3D-объектов (моделей) из вершин, ребер и полигонов (обычно треугольников).
2.  **Текстурирование (Texturing):** "Оборачивание" 3D-модели в 2D-изображения (текстуры) для придания цвета, рельефа и других свойств.
3.  **Освещение (Lighting):** Расстановка источников света в сцене.
4.  **Анимация (Animation):** "Оживление" объектов, задание их движения.
5.  **Рендеринг (Rendering):** Финальный расчет 2D-изображения на основе 3D-сцены, камеры и освещения. Это самый ресурсоемкий этап.
    *   **Rasterization (Растеризация):** Быстрый метод, используемый в реальном времени (игры). Определяет, какие пиксели экрана покрывает каждый полигон.
    *   **Ray Tracing (Трассировка лучей):** Реалистичный, но медленный метод. Симулирует физическое поведение света. Используется в кино и для создания фотореалистичных изображений. Современные видеокарты поддерживают аппаратный **Ray Tracing** в реальном времени.

**Ключевые API для 3D:**
*   **OpenGL:** Кросс-платформенный API.
*   **Vulkan:** Новый, низкоуровневый, высокопроизводительный API.
*   **DirectX:** Набор технологий от Microsoft для Windows и Xbox.

---

### **5. Сравнительная таблица: Растр vs. Вектор**

| Критерий | Растровая графика | Векторная графика |
| :--- | :--- | :--- |
| **Основа** | Пиксели (матрица) | Математические формулы (примитивы) |
| **Масштабирование** | Теряет качество (пикселизация) | Без потери качества |
| **Размер файла** | Зависит от разрешения, может быть большим | Зависит от сложности сцены, обычно мал |
| **Фотореализм** | Идеальна | Неприменима |
| **Типичное применение** | Фотографии, картины | Логотипы, иконки, чертежи, шрифты |
| **Основные форматы** | JPEG, PNG, GIF, WebP | SVG, AI, EPS, PDF (может содержать и растры) |
| **Редактирование** | Работа с областями пикселей | Работа с отдельными объектами и контурами |

---

### **6. Заключение и выводы**

1.  **Выбор типа графики зависит от задачи.**
    *   **Фото, сложные текстуры, реалистичные изображения -> Растр.**
    *   **Логотипы, иконки, шрифты, чертежи, масштабируемая графика -> Вектор.**

2.  **Разработчику** критически важно понимать разницу:
    *   Для веба: **SVG** для иконок и лого, **WebP/JPEG** для фото, **PNG** для графики с прозрачностью.
    *   Для работы с графикой в коде: использовать специализированные библиотеки (Pillow, OpenCV).

3.  **Современные технологии** (например, **WebGL**) позволяют использовать мощь 3D-графики прямо в браузере, что стирает границы между классическими типами графики и открывает новые возможности.

### **Практическое задание для дизайнеров: «Создание комплекта графики для бренда»**

**Цель:** Закрепить на практике основы работы с растровой и векторной графикой, создав согласованный комплект материалов для условного бренда.

**Инструменты:** На выбор: Adobe Photoshop (растр) + Adobe Illustrator (вектор) или Figma (универсально) или бесплатные аналоги (Photopea, Inkscape).

**Итог работы:** 3 файла: векторный логотип, обработанное растровое фото и мудборд, показывающий единство стиля.

---

### **Часть 1: Создание векторного логотипа (в Illustrator/Figma)**

**Шаг 1: Создание мудборда и выбор концепции (5-10 минут)**
*   Придумайте название для вашего условного бренда (например, «Quantum Coffee», «EcoLeaf», «Syntax Studio»).
*   Подумайте о его характере. Он технологичный, экологичный, уютный?
*   Найдите 3-4 референса (примеры логотипов, цветовые палитры, шрифты) и соберите их на одной странице (артборде). Это ваш мудборд.

**Шаг 2: Настройка документа (2 минуты)**
*   Создайте новый документ.
*   Размер: 500x500 пикселей.
*   Цветовой режим: **RGB**.

**Шаг 3: Создание знака (иконки) (15-20 минут)**
*   Используйте геометрические фигуры: Прямоугольник (R), Эллипс (L), Многоугольник.
*   **Не рисуйте от руки!** Собирайте логотип из фигур.
*   **Работа с контурами:**
    1.  Выделите две overlapping фигуры.
    2.  Используйте инструмент **«Обработка контуров»** (Pathfinder):
        *   **Объединение** (Unite): чтобы создать одну сложную фигуру.
        *   **Вычитание** (Minus Front): чтобы вырезать одну фигуру из другой.
        *   **Пересечение** (Intersect): чтобы оставить только область пересечения.
*   **Работа с кривыми:**
    *   Используйте инструмент **«Перо» (P)**, чтобы создавать собственные фигуры.
    *   Управляйте кривизной с помощью **«Узлов» (Anchor Points)** и их «рычагов».

**Шаг 4: Добавление текста (5 минут)**
*   Используйте инструмент **«Текст» (T)**.
*   Напишите название вашего бренда.
*   Подберите подходящий шрифт (не используйте больше двух разных шрифтов).
*   Выровняйте текст относительно знака.

**Шаг 5: Работа с цветом (5 минут)**
*   Используйте цветовую палитру из вашего мудборда.
*   Закрасьте фигуры (**Заливка** - Fill) и контуры (**Обводка** - Stroke).
*   Помните: хороший логотип должен читаться и в черно-белом варианте.

**Шаг 6: Экспорт (3 минуты)**
*   Сохраните исходный файл (`.ai`, `.fig`).
*   **Экспортируйте логотип в двух форматах:**
    1.  **Как SVG** (для использования в интернете).
    2.  **Как PNG на прозрачном фоне** (для соцсетей или документов).

---

### **Часть 2: Базовая растровая обработка фото (в Photoshop/Photopea)**

**Шаг 1: Настройка документа и открытие фото (2 минуты)**
*   Откройте любую свою фотографию или стоковое фото.
*   Сразу сохраните файл как `.psd` (исходник с слоями).

**Шаг 2: Базовая коррекция (5 минут)**
*   На панели **«Слои»** создайте **«Корректирующий слой»** (Adjustment Layer). Это неразрушающий метод!
    *   **«Уровни» (Levels) или «Кривые» (Curves):** Отрегулируйте точку черного, белого и средние тона, чтобы усилить контраст.
    *   **«Цветовой тон/Насыщенность» (Hue/Saturation):** Слегка увеличьте насыщенность, если цвета выглядят блекло.

**Шаг 3: Ретушь (5 минут)**
*   Увеличьте масштаб фото.
*   Возьмите инструмент **«Точечная восстанавливающая кисть» (Spot Healing Brush, J)**.
*   Установите жесткость кисти около 80-90%.
*   Аккуратно кликайте на мелкие дефекты кожи, пылинки на объективе и т.д., чтобы их удалить.

**Шаг 4: Работа со слоями и текстом (5 минут)**
*   Создайте **новый текстовый слой**.
*   Напишите на фото слоган вашего бренда или `© [Ваше Имя]`.
*   Используйте шрифт и цвет, которые перекликаются с созданным логотипом.
*   Поэкспериментируйте с **режимами наложения** (Blending Modes), например, «Мягкий свет» (Soft Light), для более органичного вписывания текста.

**Шаг 5: Кадрирование и сохранение для разных целей (5 минут)**
*   Инструментом **«Рамка» (Crop Tool, C)** обрежьте фото под формат **1:1** (для Instagram) или **16:9** (для обложки).
*   Теперь сохраните результат:
    1.  **Для печати/архива:** `Файл -> Сохранить как... -> PSD` или `TIFF` (сохраняет все слои).
    2.  **Для соцсетей (веб):** `Файл -> Экспортировать как -> Сохранить для Web (Legacy)...`
        *   Выберите формат **JPEG**.
        *   Поставьте качество **80%**. Следите за размером файла в окне предпросмотра.
        *   Нажмите «Сохранить».

---

### **Часть 3: Финальная компоновка (5 минут)**

*   Создайте новый документ в вашей программе (например, 1000x800px).
*   Разместите на нем:
    1.  Ваш мудборд (референсы).
    2.  Векторный логотип (в цвете и черно-белом варианте).
    3.  Обработанное фото с текстом.
*   Подпишите, какой инструмент и прием вы использовали на каждом этапе.
*   Экспортируйте эту страницу как **PNG** или **PDF**.

# для РПО

### **Практическое задание для разработчиков: «Автоматизация обработки изображений на Python»**

**Цель:** Освоить работу с библиотекой Pillow для программной обработки изображений, создания графики и автоматизации рутинных задач.

**Инструменты:** Python 3, библиотека Pillow (PIL), любой текстовый редактор или IDE (VS Code, PyCharm).

**Итог работы:** Несколько Python-скриптов, решающих конкретные практические задачи.

---

### **Часть 1: Установка и основы (Базовый уровень)**

**Шаг 1: Установка библиотеки**
```bash
pip install Pillow
```

**Шаг 2: Настройка структуры проекта**
Создайте папку `image_processing` и внутри нее:
```
/image_processing
    /input
        photo1.jpg
        photo2.jpg
    /output
    script_basic.py
    script_advanced.py
```
Положите любые 2-3 тестовые JPEG-фотографии в папку `input`.

---

### **Часть 2: Базовые операции (Формирование навыка)**

**Задача: Написать скрипт `script_basic.py`, который выполнит последовательность операций с одним изображением.**

**Шаг 1: Открытие и сохранение**
```python
from PIL import Image

# 1. Открываем изображение
image = Image.open("./input/photo1.jpg")

# 2. Показываем информацию о изображении
print(f"Формат: {image.format}")
print(f"Размер: {image.size}") # (width, height)
print(f"Режим: {image.mode}") # RGB, L (grayscale), etc.

# 3. Сохраняем в другом формате
image.save("./output/photo1_basic.png") # Конвертация в PNG
```

**Шаг 2: Изменение размера и поворот**
```python
# 4. Изменяем размер (ширина 400px, высота auto)
new_size = (400, int(image.height * 400 / image.width))
resized_image = image.resize(new_size, Image.Resampling.LANCZOS)

# 5. Поворачиваем на 45 градусов
rotated_image = image.rotate(45, expand=True) # expand=True чтобы не обрезать углы

# 6. Сохраняем результаты
resized_image.save("./output/photo1_resized.jpg")
rotated_image.save("./output/photo1_rotated.jpg")
```

**Шаг 3: Конвертация и обрезка**
```python
# 7. Конвертируем в черно-белое
grayscale_image = image.convert("L")
grayscale_image.save("./output/photo1_bw.jpg")

# 8. Обрезаем изображение (левый_верхний_x, левый_верхний_y, правый_нижний_x, правый_нижний_y)
cropped_image = image.crop((100, 100, 400, 400)) # Квадрат 300x300
cropped_image.save("./output/photo1_cropped.jpg")
```

---

### **Часть 3: Пакетная обработка и водяные знаки (Практическое применение)**

**Задача: Написать скрипт `script_batch.py` для автоматической обработки всех изображений в папке.**

**Шаг 1: Создание функции-обработчика**
```python
from PIL import Image, ImageDraw, ImageFont
import os

def process_image(input_path, output_path, watermark_text="@developer"):
    """Обрабатывает одно изображение: ресайз + водяной знак"""
    
    with Image.open(input_path) as img:
        # Создаем копию для работы
        working_img = img.copy()
        
        # Ресайз до ширины 800px
        if working_img.width > 800:
            new_height = int((800 / working_img.width) * working_img.height)
            working_img = working_img.resize((800, new_height), Image.Resampling.LANCZOS)
        
        # Добавляем водяной знак
        draw = ImageDraw.Draw(working_img)
        
        try:
            # Пробуем использовать системный шрифт
            font = ImageFont.truetype("arial.ttf", 20)
        except:
            # Если шрифт не найден, используем стандартный
            font = ImageFont.load_default()
        
        # Получаем размеры текста
        bbox = draw.textbbox((0, 0), watermark_text, font=font)
        text_width = bbox[2] - bbox[0]
        text_height = bbox[3] - bbox[1]
        
        # Позиция в правом нижнем углу с отступом
        margin = 10
        x = working_img.width - text_width - margin
        y = working_img.height - text_height - margin
        
        # Рисуем текст с черной обводкой для читаемости
        draw.text((x-1, y-1), watermark_text, font=font, fill="black")
        draw.text((x+1, y-1), watermark_text, font=font, fill="black")
        draw.text((x-1, y+1), watermark_text, font=font, fill="black")
        draw.text((x+1, y+1), watermark_text, font=font, fill="black")
        draw.text((x, y), watermark_text, font=font, fill="white")
        
        # Сохраняем результат
        working_img.save(output_path, "JPEG", quality=85)
        print(f"Обработано: {os.path.basename(input_path)}")
```

**Шаг 2: Обработка всех файлов в папке**
```python
def process_folder(input_folder, output_folder, watermark_text):
    """Обрабатывает все изображения в папке"""
    
    # Создаем папку output если её нет
    os.makedirs(output_folder, exist_ok=True)
    
    # Поддерживаемые форматы
    supported_formats = ('.jpg', '.jpeg', '.png', '.webp')
    
    # Обрабатываем каждый файл
    for filename in os.listdir(input_folder):
        if filename.lower().endswith(supported_formats):
            input_path = os.path.join(input_folder, filename)
            
            # Создаем новое имя файла
            name, ext = os.path.splitext(filename)
            output_filename = f"{name}_processed.jpg"
            output_path = os.path.join(output_folder, output_filename)
            
            # Обрабатываем изображение
            process_image(input_path, output_path, watermark_text)

# Запускаем обработку
if __name__ == "__main__":
    process_folder("./input", "./output", "© Developer Team 2024")
    print("Пакетная обработка завершена!")
```

---

### **Часть 4: Создание генеративной графики (Продвинутый уровень)**

**Задача: Создать скрипт `script_generative.py` для генерации абстрактных композиций.**

```python
from PIL import Image, ImageDraw
import random
import math

def create_generative_art(width=800, height=600, filename="./output/generative_art.png"):
    """Создает генеративное абстрактное изображение"""
    
    # Создаем новое изображение
    img = Image.new('RGB', (width, height), color='white')
    draw = ImageDraw.Draw(img)
    
    # Генерируем 50 случайных кругов
    for _ in range(50):
        # Случайные параметры круга
        x = random.randint(0, width)
        y = random.randint(0, height)
        radius = random.randint(10, 100)
        
        # Случайный цвет с прозрачностью
        color = (
            random.randint(0, 255),
            random.randint(0, 255), 
            random.randint(0, 255)
        )
        
        # Рисуем круг
        draw.ellipse(
            [x-radius, y-radius, x+radius, y+radius],
            fill=color,
            outline=None
        )
    
    # Добавляем несколько линий для структуры
    for _ in range(10):
        x1, y1 = random.randint(0, width), random.randint(0, height)
        x2, y2 = random.randint(0, width), random.randint(0, height)
        
        line_color = (
            random.randint(0, 255),
            random.randint(0, 255),
            random.randint(0, 255)
        )
        
        draw.line([x1, y1, x2, y2], fill=line_color, width=3)
    
    # Сохраняем результат
    img.save(filename, "PNG")
    print(f"Генеративное искусство сохранено как {filename}")

# Создаем 3 разных варианта
for i in range(3):
    create_generative_art(filename=f"./output/generative_art_{i+1}.png")
```

---

### **Часть 5: Дополнительные вызовы (Для самых быстрых)**

**Задача 1: Создание коллажа**
```python
def create_collage(image_paths, output_path, collage_size=(1200, 800)):
    """Создает коллаж из нескольких изображений"""
    collage = Image.new('RGB', collage_size, 'white')
    
    x_offset = 0
    for img_path in image_paths:
        with Image.open(img_path) as img:
            # Ресайзим изображения для коллажа
            img.thumbnail((400, 400))
            collage.paste(img, (x_offset, 0))
            x_offset += img.width
    
    collage.save(output_path)
    print(f"Коллаж сохранен: {output_path}")
```

**Задача 2: Применение фильтров**
```python
from PIL import ImageFilter

def apply_filters(image_path, output_path):
    """Применяет различные фильтры к изображению"""
    with Image.open(image_path) as img:
        # Размытие
        blurred = img.filter(ImageFilter.GaussianBlur(5))
        blurred.save(output_path.replace('.jpg', '_blurred.jpg'))
        
        # Контур
        edges = img.filter(ImageFilter.FIND_EDGES)
        edges.save(output_path.replace('.jpg', '_edges.jpg'))
        
        # Ч/Б
        bw = img.convert('L')
        bw.save(output_path.replace('.jpg', '_bw.jpg'))
```

### **ФИНАЛЬНОЕ ЗАДАНИЕ (РПО): «УМНЫЙ КОНВЕЙЕР ОБРАБОТКИ ИЗОБРАЖЕНИЙ»**

**Цель:** Проанализировать, модифицировать и улучшить готовый код обработки изображений, решив серию взаимосвязанных задач.

---

### **ЧАСТЬ 1: АНАЛИЗ И ДЕБАГГИНГ (30 баллов)**

Вам дан «кривой» скрипт `buggy_processor.py`, который должен создавать коллажи, но работает неправильно.

```python
from PIL import Image
import os
import random

def create_collage_from_folder(folder_path, output_path, rows=2, cols=2):
    images = []
    for file in os.listdir(folder_path):
        if file.endswith('.jpg'):
            img = Image.open(file)  # БАГ 1
            images.append(img)
    
    if len(images) < rows * cols:
        print("Недостаточно изображений")
        return
    
    # БАГ 2
    width = images[0].width
    height = images[0].height
    
    collage = Image.new('RGB', (cols * width, rows * height))
    
    for i in range(rows):
        for j in range(cols):
            index = i * cols + j
            if index < len(images):
                # БАГ 3
                collage.paste(images[index], (j * height, i * width))
    
    collage.save(output_path)

# Эта функция тоже сломана
def create_smart_gradient(size=(400, 400), start_color=(255,0,0), end_color=(0,0,255)):
    img = Image.new('RGB', size, color=start_color)
    draw = ImageDraw.Draw(img)
    
    for x in range(size[0]):
        for y in range(size[1]):
            # БАГ 4
            r = start_color[0] + (end_color[0] - start_color[0]) * x / size[0]
            g = start_color[1] + (end_color[1] - start_color[1]) * y / size[1]  
            b = start_color[2]  # БАГ 5
            
            draw.point((x, y), fill=(int(r), int(g), int(b)))
    
    return img
```

**Задачи:**
1. **Найдите и исправьте ВСЕ баги** в обеих функциях (минимум 5 серьезных ошибок)
2. **Объясните письменно**, в чем заключалась каждая ошибка и почему ваше исправление работает
3. **Протестируйте** исправленные функции на разных наборах данных

---

### **ЧАСТЬ 2: ТВОРЧЕСКОЕ РАСШИРЕНИЕ**

На основе предыдущих заданий создайте **«Умный анализатор изображений»** со следующими функциями:

**Задача 1: Автоматическая классификация по доминирующему цвету**
```python
def analyze_dominant_color(image_path):
    """
    Проанализировать изображение и определить:
    - Доминирующий цвет (RGB)
    - Цветовую температуру (теплое/холодное/нейтральное)
    - Яркость изображения (темное/среднее/светлое)
    """
    # ДОДЕЛАТЬ: использовать гистограммы и статистику
    pass
```

**Задача 2: Контекстно-зависимая обработка**
```python
def smart_processing(image_path, output_path):
    """
    Автоматически определить тип изображения и применить оптимальную обработку:
    - ПОРТРЕТ: легкое размытие фона, коррекция кожи
    - ПЕЙЗАЖ: усиление насыщенности, контраста
    - ТЕКСТ: повышение резкости, конвертация в ч/б
    - НОЧНОЕ: шумоподавление, коррекция экспозиции
    """
    # ДОДЕЛАТЬ: алгоритм классификации + соответствующие фильтры
    pass
```

**Критерии сложности:**
- Алгоритм должен анализировать **гистограммы**, **контраст**, **распределение цветов**
- Использовать **эвристики** (например, много зеленого → пейзаж, много телесных оттенков → портрет)
- **Нельзя** использовать готовые ML-модели — только анализ средствами Pillow

---

### **ЧАСТЬ 3: ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ**

Дан «медленный» скрипт обработки:

```python
def slow_batch_processor(input_folder, output_folder):
    """Очень медленная обработка 1000+ изображений"""
    for filename in os.listdir(input_folder):
        if filename.lower().endswith(('.jpg', '.png')):
            with Image.open(os.path.join(input_folder, filename)) as img:
                result = apply_complex_filters(img)
                result.save(os.path.join(output_folder, filename))
```

**Задачи:**
1. **Проанализируйте узкие места** (I/O операции, алгоритмическая сложность)
2. **Предложите 3 конкретных оптимизации** с обоснованием
3. **Реализуйте самую эффективную оптимизацию** (многопоточность, кэширование, etc.)

**Пример решения:**
```python
from concurrent.futures import ThreadPoolExecutor
import threading

def optimized_batch_processor(input_folder, output_folder, max_workers=4):
    """Оптимизированная многопоточная версия"""
    files = [f for f in os.listdir(input_folder) if f.lower().endswith(('.jpg', '.png'))]
    
    def process_single_file(filename):
        with Image.open(os.path.join(input_folder, filename)) as img:
            result = apply_complex_filters(img)
            result.save(os.path.join(output_folder, filename))
    
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        executor.map(process_single_file, files)
```

---

### **БОНУС: АНТИ-ПЛАГИАТ ЗАДАЧА**

**«Уникальный визуальный водяной знак»**

Создайте функцию, которая генерирует **уникальный водяной знак для каждого пользователя** на основе его данных:

```python
def generate_personal_watermark(user_id, username, size=(200, 100)):
    """
    Создать уникальный водяной знак, который:
    - Включает инициалы пользователя в виде геометрического паттерна
    - Использует цветовую схему на основе хеша user_id
    - Имеет сложную прозрачность (не просто полупрозрачный текст)
    - Содержит скрытые элементы, видимые только при определенной обработке
    """
    # РЕАЛИЗОВАТЬ: геометрические преобразования, работа с альфа-каналом
    pass
```

**Требования:**
- Водяной знак должен **визуально отличаться** для разных пользователей
- Должен быть **устойчив** к простому кропингу и изменению размера
- Код должен использовать **неочевидные математические преобразования**

ЖДУ В РЕПО: исправленный код + письменный отчет с объяснениями (Примеры изображений можно в архив и к дз в Journal)
